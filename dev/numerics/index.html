<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical methods · OceanTurb.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>OceanTurb.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>Numerical methods</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Spatial-discretization-1">Spatial discretization</a></li><li class="toplevel"><a class="toctext" href="#Time-integration-1">Time integration</a></li><li><a class="toctext" href="#Time-integration-methods-1">Time integration methods</a></li></ul></li><li><span class="toctext">Boundary layer models</span><ul><li><a class="toctext" href="../models/basics/">Primer on boundary layer modeling</a></li><li><a class="toctext" href="../models/kpp/">The K-Profile-Parameterization (KPP)</a></li><li><a class="toctext" href="../models/edmf/">The eddy-diffusivity mass-flux (EDMF) schemes</a></li><li><a class="toctext" href="../models/pacanowskiphilander/">Pacanowski-Philander</a></li></ul></li><li><span class="toctext">DocStrings</span><ul><li><a class="toctext" href="../man/types/">Private types</a></li><li><a class="toctext" href="../man/functions/">Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Numerical methods</a></li></ul><a class="edit-page" href="https://github.com/glwagner/OceanTurb.jl/blob/master/docs/src/numerics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Numerical methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Numerical-methods-in-OceanTurb.jl-1" href="#Numerical-methods-in-OceanTurb.jl-1">Numerical methods in <code>OceanTurb.jl</code></a></h1><p><code>OceanTurb.jl</code> uses a one-dimensional finite-volume method to discretize momentum, temperature, salinity, and other variables in the <span>$z$</span>-direction. A variety of explicit and implicit-explicit schemes are implemented for temporal integration. At the moment, we only support the treatment of diffusive operators implicitly for semi-implicit time-integration.</p><h1><a class="nav-anchor" id="Spatial-discretization-1" href="#Spatial-discretization-1">Spatial discretization</a></h1><p>An ASCII-art respresentation of an example grid with <code>N=3</code> is</p><pre><code class="language-text"> ▲ z
 |
         i=4           *         
                j=4   ===  Top   ▲              
         i=3           *         | Δf[3]
                j=3   ---        ▼
         i=2           *             ▲            
                j=2   ---            | Δc[2]
         i=1           *             ▼  
                j=1   ===  Bottom
         i=0           *           </code></pre><p>where the double lines indicate the top and bottom of the domain, the single lines indicate &quot;face&quot; boundaries, the <code>i</code>&#39;s index cell centers (nodes) and <code>j</code>&#39;s index the <span>$z$</span>-location of cell interfaces (faces). Horizontal momentum and tracer variables are located at cell centers, while fluxes of these quantities (and vertical-velocity-like variables when present) are located at cell faces. The cells at <span>$i=0$</span> and <span>$i=4$</span> are &#39;ghost cells&#39;, whose values are set according to the boundary condition. For a no flux or zero gradient boundary condition, for example, we would set <code>c[0]=c[1]</code> and <code>c[4]=c[3]</code>.</p><h3><a class="nav-anchor" id="Finite-volume-derivatives-and-fluxes-1" href="#Finite-volume-derivatives-and-fluxes-1">Finite volume derivatives and fluxes</a></h3><p>The derivative of a quantity <span>$\Phi$</span> at face <span>$i$</span> is</p><div>\[\newcommand{\c}{\, ,}
\newcommand{\p}{\, .}
\newcommand{\d}{\partial}

\newcommand{\r}[1]{\mathrm{#1}}

\newcommand{\ee}{\mathrm{e}}

\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}

\newcommand{\beqs}{\begin{gather}}
\newcommand{\eeqs}{\end{gather}}

\beq
\left( \d_z \Phi \right )_i = \frac{\Phi_i - \Phi_{i-1}}{\Delta c_i} \c
\eeq\]</div><p>where <span>$\Phi_i$</span> denotes the value of <span>$\Phi$</span> at cell <span>$i$</span>, and <span>$\Delta c_i = z_{c, i} - z_{c, i-1}$</span> is the vertical separation between node <span>$i$</span> and cell point <span>$i-1$</span>.</p><p>With diffusivity given on cell interfaces, the diffusive flux at face <span>$i$</span> is just <span>$K_i \left ( \d_z \Phi \right )_i$</span>. The (negative of the) divergence of the diffusive flux at node <span>$i$</span> is therefore</p><div>\[\newcommand{\Kdz}[1]{K_{#1} \left ( \d_z \Phi \right )_{#1} }
\begin{align}
\left ( \d_z K \d_z \Phi \right )_i &amp;= \frac{ \Kdz{i+1} - \Kdz{i} }{\Delta f_i} \c \\
&amp;= \frac{
          \tfrac{K_{i+1}}{\Delta c_{i+1}} \Phi_{i+1}
        - \left ( \tfrac{K_{i+1}}{\Delta c_{i+1}} + \tfrac{K_i}{\Delta c_i} \right ) \Phi_i
         + \tfrac{K_i}{\Delta c_i} \Phi_{i-1}}{\Delta f_i} \p
 \label{fluxdivop}
\end{align}\]</div><p>In the top cell where <span>$i=N$</span>, the diffusive flux is</p><div>\[\begin{align}
\left ( \d_z K \d_z \Phi \right )_N &amp;= \frac{ - F_{\mathrm{top}} - K_N \left ( \d_z \Phi \right )_N}{\Delta f_N} \c \\
&amp;= -\frac{F_{\mathrm{top}}}{\Delta f_N} - \frac{K_N \Phi_N - K_N \Phi_{N-1}}{\Delta f_N \Delta c_N} \p
 \label{fluxdivop_top}
\end{align}\]</div><p>In the bottom cell where <span>$i=1$</span>, on the other hand, the diffusive flux is</p><div>\[\begin{align}
\left ( \d_z K \d_z \Phi \right )_1 &amp;= \frac{  K_2 \left ( \d_z \Phi \right )_2 + F_{\mathrm{bottom}}}{\Delta f_1} \c \\
&amp;= \frac{F_{\mathrm{bottom}}}{\Delta f_1} + \frac{K_2 \Phi_2 - K_2 \Phi_1}{\Delta f_1 \Delta c_2}
\label{fluxdivop_bottom}
\end{align}\]</div><h1><a class="nav-anchor" id="Time-integration-1" href="#Time-integration-1">Time integration</a></h1><p>To integrate ocean surface boundary layer models forward in time, we implement various explicit and implicit-explicit time-stepping schemes. The function <code>iterate!(model, Δt, Nt)</code> steps a model forward in time.</p><p>Timesteppers in <code>OceanTurb.jl</code> integrate equations of the form</p><div>\[\beq \label{equationform}
\d_t \Phi = \d_z K \d_z \Phi + R(\Phi) \c
\eeq\]</div><p>where <span>$\Phi(z, t)$</span> is a variable like velocity, temperature, or salinity, <span>$K$</span> is a diffusivity which is a general nonlinear function of <span>$\Phi$</span>, <span>$z$</span>, and external parameters, and <span>$R$</span> is an arbitrary function representing any number of processes, including the Coriolis force or external forcing.</p><h2><a class="nav-anchor" id="Time-integration-methods-1" href="#Time-integration-methods-1">Time integration methods</a></h2><p>We implement <code>iterate!</code> functions and types for:</p><ul><li>explicit forward Euler</li><li>semi-implicit backward Euler</li></ul><h3><a class="nav-anchor" id="Forward-Euler-method-1" href="#Forward-Euler-method-1">Forward Euler method</a></h3><p>The explicit forward Euler time integration scheme uses</p><div>\[\beq
\Phi^{n+1} = \Phi^{n} + \Delta t \, \big [ \left ( \d_z K^n \d_z \right ) \Phi^n + R \left ( \Phi^n \right ) \big ]
\eeq\]</div><p>where the superscripts <span>$n$</span> and <span>$n+1$</span> denote the solution at time-step <span>$n$</span> and <span>$n+1$</span>, respectively.</p><h3><a class="nav-anchor" id="Backward-Euler-method-1" href="#Backward-Euler-method-1">Backward Euler method</a></h3><p>The backward Euler method uses the temporal discretization</p><div>\[\beq
\Phi^{n+1} - \Delta t \left ( \d_z K^n \d_z \right ) \Phi^{n+1} = \Phi^n + \Delta t R(\Phi^n)
\eeq\]</div><p>The <span>$z$</span>-derivatives in the diffusive term generate a matrix problem to be solved for <span>$\Phi^{n+1}$</span>:</p><div>\[\beq
L^n_{ij} \Phi^{n+1}_j = \left [ \Phi^n + \Delta t R \left ( \Phi^n \right ) \right ]_i
\eeq\]</div><p>where <span>$L^n_{ij}$</span> is a matrix operator at time-step <span>$n$</span>, and the subscripts <span>$i$</span> or <span>$j$</span> denote grid points <span>$i$</span> or <span>$j$</span>. For the diffusive problems considered by our backward Euler solver, the matrix multiplication <span>$L^n_{ij} \Phi_j^{n+1}$</span> has the form</p><div>\[\begin{align}
L^n_{ij} \Phi_j^{n+1} &amp;= \left [ 1 - \Delta t \left (\d_z K^n \d_z \right ) \right ]_{ij} \Phi_j^{n+1} \\

&amp;= \left [ \begin{matrix}

1 + \Delta t \tfrac{K^n_2}{\Delta f_1 \Delta c_2}
  &amp; -\Delta t \tfrac{K^n_2}{\Delta f_1 \Delta c_2}
    &amp; \cdot &amp; \cdot &amp; \cdot &amp; \cdot \\

\ddots &amp; \ddots &amp; \ddots &amp; \cdot &amp; \cdot &amp; \cdot \\

\cdot
  &amp; - \Delta t \tfrac{K^n_i}{\Delta c_i \Delta f_i}
  &amp; 1 + \tfrac{\Delta t}{\Delta f_i} \left ( \tfrac{K^n_{i+1}}{\Delta c_{i+1}} + \tfrac{K^n_i}{\Delta c_i} \right )
  &amp; - \Delta t \tfrac{K^n_{i+1}}{\Delta c_{i+1} \Delta f_{i+1}} &amp; \cdot &amp; \cdot \\

\cdot &amp; \cdot &amp; \ddots &amp; \ddots &amp; \ddots &amp; \cdot \\

\cdot &amp; \cdot &amp; \cdot &amp; \cdot &amp; - \Delta t \tfrac{K^n_N}{\Delta c_N \Delta f_N}
  &amp; 1 + \Delta t \tfrac{K^n_N}{\Delta c_N \Delta f_N}
\end{matrix} \right ]
\left [ \begin{matrix}
\Phi^{n+1}_1 \\[1.1ex]
\vdots \\[1.1ex]
\Phi^{n+1}_i \\[1.1ex]
\vdots \\[1.1ex]
\Phi^{n+1}_N
\end{matrix} \right ]
\label{implicitoperatormatrix}
\end{align}\]</div><p>To form the matrix operator in \eqref{implicitoperatormatrix}, we have used the second-order flux divergence finite difference operators in \eqref{fluxdivop}–\eqref{fluxdivop_bottom}.</p><p>It is crucial to note that the diffusive operator that contributes to <span>$L^n_{ij}$</span> does not include fluxes across boundary faces. In particular, <span>$L^n_{ij}$</span> in \eqref{implicitoperatormatrix} enforces a no-flux condition across the top and bottom faces. Accordingly, fluxes through boundary faces due either to Dirichlet (Value) boundary conditions or non-zero fluxes are accounted for by adding the contribution of the flux diverence across the top and bottom face to <span>$R \left ( \Phi \right )$</span>.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../models/basics/"><span class="direction">Next</span><span class="title">Primer on boundary layer modeling</span></a></footer></article></body></html>
