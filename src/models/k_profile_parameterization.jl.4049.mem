        - module KPP
        - 
        - using
        -     OceanTurb,
        -     LinearAlgebra
        - 
        - import OceanTurb: Constants
        - 
        - const nsol = 4
        - @solution U V T S
        - 
        - #=
        - struct Solution{A, G, T} <: AbstractSolution{4, AbstractField}
        - 
        - end
        - =#
        - 
        - 
        - """
        -     Parameters(; kwargs...)
        - 
        - Construct KPP parameters.
        - """
        - @Base.kwdef struct Parameters{T<:AbstractFloat} <: AbstractParameters
        -     CSL   :: T  = 0.1   # Surface layer fraction
        -     CœÑ    :: T  = 0.4   # Von Karman constant
        -     CNL   :: T  = 6.33  # Non-local flux proportionality constant
        - 
        -     Cstab :: T  = 2.0   # Stable buoyancy flux parameter for wind-driven turbulence
        -     Cunst :: T  = 6.4   # Unstable buoyancy flux parameter for wind-driven turbulence
        - 
        -        Cn :: T  = 1.0   # Exponent for effect of stable buoyancy forcing on wind mixing
        -     CmœÑ_U :: T  = 0.25  # Exponent for effect of unstable buoyancy forcing on wind mixing of U
        -     CmœÑ_T :: T  = 0.5   # Exponent for effect of unstable buoyancy forcing on wind mixing of T
        -     Cmb_U :: T  = 1/3   # Exponent for the effect of wind on convective mixing of U
        -     Cmb_T :: T  = 1/3   # Exponent for effect of wind on convective mixing of T
        - 
        -     Cd_U  :: T  = 0.5   # Wind mixing regime threshold for momentum
        -     Cd_T  :: T  = 2.5   # Wind mixing regime threshold for tracers
        - 
        -     Cb_U  :: T  = 0.599 # Buoyancy flux parameter for convective turbulence
        -     Cb_T  :: T  = 1.36  # Buoyancy flux parameter for convective turbulence
        -     CœÑb_U :: T  = (CœÑ / Cb_U)^(1/Cmb_U) * (1 + Cunst*Cd_U)^(CmœÑ_U/Cmb_U) - Cd_U  # Wind stress parameter for convective turbulence
        -     CœÑb_T :: T  = (CœÑ / Cb_T)^(1/Cmb_T) * (1 + Cunst*Cd_T)^(CmœÑ_T/Cmb_T) - Cd_T  # Wind stress parameter for convective turbulence
        - 
        -     CRi   :: T  = 0.3   # Critical bulk Richardson number
        -     CKE   :: T  = 4.32  # Unresolved turbulence parameter
        -     CKE‚ÇÄ  :: T  = 1e-11 # Minimum unresolved turbulence kinetic energy
        - 
        -     KU‚ÇÄ   :: T  = 1e-6  # Interior viscosity for velocity
        -     KT‚ÇÄ   :: T  = 1e-7  # Interior diffusivity for temperature
        -     KS‚ÇÄ   :: T  = 1e-9  # Interior diffusivity for salinity
        - end
        - 
        - # Shape functions.
        - # 'd' is a non-dimensional depth coordinate.
        - default_NL_shape(d) = ifelse(0<d<1, d*(1-d)^2, -zero(d))
        - const default_K_shape = default_NL_shape
        - 
        - mutable struct State{T} <: FieldVector{6, T}
        -     Fu :: T
        -     Fv :: T
        -     FŒ∏ :: T
        -     Fs :: T
        -     Fb :: T
        -     h  :: T
        - end
        - 
        - State(T=Float64) = State{T}(0, 0, 0, 0, 0, 0)
        - 
        - Fb(g, Œ±, Œ≤, FŒ∏, Fs) = g * (Œ±*FŒ∏ - Œ≤*Fs)
        - 
        - """
        -     update_state!(model)
        - 
        - Update the top flux conditions and mixing depth for `model`
        - and store in `model.state`.
        - """
        - function update_state!(m)
   786952     m.state.Fu = getbc(m, m.bcs.U.top)
   716960     m.state.Fv = getbc(m, m.bcs.V.top)
   716960     m.state.FŒ∏ = getbc(m, m.bcs.T.top)
   716960     m.state.Fs = getbc(m, m.bcs.S.top)
        0     m.state.Fb = Fb(m.constants.g, m.constants.Œ±, m.constants.Œ≤, m.state.FŒ∏, m.state.Fs)
   718352     m.state.h  = mixing_depth(m)
        0     return nothing
        - end
        - 
        - mutable struct Model{TS, G, T} <: AbstractModel{TS, G, T}
   566232     @add_standard_model_fields
        -     parameters :: Parameters{T}
        -     constants  :: Constants{T}
        -     state      :: State{T}
        - end
        - 
        - function Model(; N=10, L=1.0,
        -             grid = UniformGrid(N, L),
        -        constants = Constants(),
        -       parameters = Parameters(),
        -          stepper = :ForwardEuler,
        -              bcs = BoundaryConditions((ZeroFluxBoundaryConditions() for i=1:nsol)...)
        -     )
        - 
        -       #K = Accessory{Function}(KU, KV, KT, KS)
        -       #R = Accessory{Function}(RU, RV, RT, RS)
  1491648       K = (KU, KV, KT, KS)
        -       R = (RU, RV, RT, RS)
        -     eqn = Equation(R, K, update_state!)
        - 
        0     solution = Solution((CellField(grid) for i=1:nsol)...)
       48          lhs = OceanTurb.build_lhs(solution)
        0     timestepper = Timestepper(stepper, eqn, solution, lhs)
        - 
       96     return Model(Clock(), grid, timestepper, solution, bcs, parameters, constants, State())
        - end
        - 
        - # Note: we use 'm' to refer to 'model' in function definitions below.
        - 
        - ## ** The K-Profile-Parameterization **
        - K_KPP(h, ùí≤, d, shape=default_K_shape) = ifelse(0<d<1, max(zero(h), h*ùí≤*shape(d)), -zero(h))
        - 
        - d(m, i) = @inbounds ifelse(m.state.h>0, -m.grid.zf[i]/m.state.h, -zero(m.state.h))
        - 
        - "Return the buoyancy gradient at face point i."
        0 ‚àÇB‚àÇz(T, S, g, Œ±, Œ≤, i) = g * (Œ±*‚àÇz(T, i) - Œ≤*‚àÇz(S, i))
        - 
        - #
        - # Diagnosis of mixing depth "h"
        - #
        - 
        - "Returns the surface_layer_average for mixing depth h = -zf[i]."
        - function surface_layer_average(c, CSL, i)
        0     if i > c.grid.N # Return surface value
        0         return onface(c, c.grid.N+1)
        -     else
        0         iŒµ = length(c)+1 - CSL*(length(c)+1 - i) # (fractional) face "index" of the surface layer
        0         face = ceil(Int, iŒµ)  # next cell face above the fractional depth
        0         frac = face - iŒµ # fraction of lowermost cell in the surface layer.
        -         surface_layer_integral = zero(eltype(c))
        - 
        -         # Contribution of fractional cell to total integral
        0         surface_layer_integral += frac * Œîf(c, face-1) * c[face-1]
        - 
        -         # Add cells above face, if there are any.
        0         for j = face:length(c)
        0             @inbounds surface_layer_integral += Œîf(c, j) * c[j]
        -         end
        - 
        0         h = -c.grid.zf[i] # depth
        - 
        0         return surface_layer_integral / (CSL*h)
        -     end
        - end
        - 
        - """
        - Return Œîc(h·µ¢), the difference between the surface-layer average of c and its value at depth h·µ¢, where
        - i is a face index.
        - """
        - Œî(c, CSL, i) = surface_layer_average(c, CSL, i) - onface(c, i)
        - 
        - "Returns the parameterization for unresolved KE at face point i."
        - function unresolved_kinetic_energy(h, Bz, Fb, CKE, CKE‚ÇÄ, g, Œ±, Œ≤)
        0     return CKE * h^(4/3) * sqrt(max(0, Bz)) * max(0, Fb)^(1/3) + CKE‚ÇÄ
        - end
        - 
        - """
        -     bulk_richardson_number(model, i)
        - 
        - Returns the bulk Richardson number of `model` at face `i`.
        - """
        - @inline function bulk_richardson_number(U, V, T, S, Fb::TT, 
        -                                 CKE::TT, CKE‚ÇÄ::TT, CSL::TT, g::TT, Œ±::TT, Œ≤::TT, i) where TT
330928954     h = -U.grid.zf[i]
        -     # (h - hŒµ) * ŒîB
        0     h‚Å∫ŒîB = h * (1.0 - 0.5CSL) * g * (Œ±*Œî(T, CSL, i) - Œ≤*Œî(S, CSL, i))
        - 
        0     KE = (Œî(U, CSL, i)^2 + Œî(V, CSL, i)^2 
        -               + unresolved_kinetic_energy(h, ‚àÇB‚àÇz(T, S, g, Œ±, Œ≤, i), Fb, CKE, CKE‚ÇÄ, g, Œ±, Œ≤))
        - 
        0     if KE == 0 && h‚Å∫ŒîB == 0 # Alistar Adcroft's theorem
        0         return -zero(T)
        -     else
        0         return h‚Å∫ŒîB / KE
        -     end
        - end
        - 
 46243920 bulk_richardson_number(m, i) = bulk_richardson_number(
        -     m.solution.U, m.solution.V, m.solution.T, m.solution.S,
        -     m.state.Fb, m.parameters.CKE, m.parameters.CKE‚ÇÄ, m.parameters.CSL, m.constants.g,
        -     m.constants.Œ±, m.constants.Œ≤, i)
        - 
        - """
        -     mixing_depth(model)
        - 
        - Calculate the mixing depth 'h' for `model`.
        - """
        - function mixing_depth(m)
        0     ih‚ÇÅ = m.grid.N + 1 # start at top.
        0     Ri‚ÇÅ = bulk_richardson_number(m, ih‚ÇÅ) # should be 0.
        - 
        -     # Descend through grid until Ri rises above critical value
 45886608     while ih‚ÇÅ > 1 && Ri‚ÇÅ < m.parameters.CRi
        0         ih‚ÇÅ -= 1 # descend
        0         Ri‚ÇÅ = bulk_richardson_number(m, ih‚ÇÅ)
        -     end
        - 
        -     # Edge cases:
        -     # 1. Mixing depth is at the top of the domain (z=0):
        0     if ih‚ÇÅ == m.grid.N + 1
        0         z‚òÖ = m.grid.zf[ih‚ÇÅ]
        - 
        -     # 2. Mixing depth is whole domain because Ri is always less than CRi:
   358480     elseif ih‚ÇÅ == 1 && Ri‚ÇÅ < m.parameters.CRi
        0         z‚òÖ = m.grid.zf[ih‚ÇÅ]
        - 
        -     # 3. Ri is infinite somewhere inside the domain.
        0     elseif !isfinite(Ri‚ÇÅ)
        0         z‚òÖ = m.grid.zc[ih‚ÇÅ]
        - 
        -     # Main case: mixing depth is in the interior.
        -     else # Ri‚ÇÅ > CRi
        0         ŒîRi = bulk_richardson_number(m, ih‚ÇÅ+1) - Ri‚ÇÅ # <0 linearly interpolate to find h.
        -         # x = x‚ÇÄ + Œîx * (y-y‚ÇÄ) / Œîy
        0         z‚òÖ = m.grid.zf[ih‚ÇÅ] + Œîf(m.grid, ih‚ÇÅ) * (m.parameters.CRi - Ri‚ÇÅ) / ŒîRi
        -     end
        - 
   720096     -z‚òÖ < 0 && @warn "mixing depth $(-z‚òÖ) is negative"
        - 
   358480     return -z‚òÖ # "depth" is negative height.
        - end
        - 
        - #
        - # Vertical velocity scale
        - #
        - 
        - "Return true if the boundary layer is unstable and convecting."
        - isunstable(model) = model.state.Fb > 0
        - 
        - "Return true if the boundary layer is forced."
        - isforced(model) = model.state.Fu != 0 || model.state.Fv != 0 || model.state.Fb != 0
        - 
        - "Return the turbuent velocity scale associated with wind stress."
        - œâœÑ(Fu, Fv) = (Fu^2 + Fv^2)^(1/4)
        - œâœÑ(m::AbstractModel) = œâœÑ(m.state.Fu, m.state.Fv)
        - 
        - "Return the turbuent velocity scale associated with convection."
        - œâb(Fb, h) = abs(h * Fb)^(1/3)
        - œâb(m::AbstractModel) = œâb(m.state.Fb, m.state.h)
        - 
        - "Return the vertical velocity scale at depth d for a stable boundary layer."
        - ùí≤_stable(CœÑ, Cstab, Cn, œâœÑ, œâb, d) = CœÑ * œâœÑ / (1 + Cstab * d * (œâb/œâœÑ)^3)^Cn
        - 
        - "Return the vertical velocity scale at scaled depth dœµ for an unstable boundary layer."
        - @inline function ùí≤_unstable(CSL, Cd, CœÑ, Cunst, Cb, CœÑb, CmœÑ, Cmb, œâœÑ, œâb, d)
        -     dœµ = min(CSL, d)
        -     if dœµ < Cd * (œâœÑ/œâb)^3
        -         return CœÑ * œâœÑ * (1 + Cunst * dœµ * (œâb/œâœÑ)^3)^CmœÑ
        -     else
        -         return Cb * œâb * (dœµ + CœÑb * (œâœÑ/œâb)^3)^Cmb
        -     end
        - end
        - 
        - @inline function ùí≤_unstable_U(m, i)
        -     return ùí≤_unstable(m.parameters.CSL, m.parameters.Cd_U,
        -                             m.parameters.CœÑ, m.parameters.Cunst,
        -                             m.parameters.Cb_U, m.parameters.CœÑb_U,
        -                             m.parameters.CmœÑ_U, m.parameters.Cmb_U,
        -                             œâœÑ(m), œâb(m), d(m, i)
        -                             )
        - end
        - 
        - @inline function ùí≤_unstable_T(m, i)
        -     return ùí≤_unstable(m.parameters.CSL, m.parameters.Cd_T,
        -                             m.parameters.CœÑ, m.parameters.Cunst,
        -                             m.parameters.Cb_T, m.parameters.CœÑb_T,
        -                             m.parameters.CmœÑ_T, m.parameters.Cmb_T,
        -                             œâœÑ(m), œâb(m), d(m, i)
        -                             )
        - end
        - 
        - @inline function ùí≤_stable(m, i)
        -     return ùí≤_stable(m.parameters.CœÑ, m.parameters.Cstab, m.parameters.Cn,
        -                           œâœÑ(m), œâb(m), d(m, i)
        -                           )
        - end
        - 
        - "Return the turbulent velocity scale for momentum at face point i."
        - @inline function ùí≤_U(m::AbstractModel{TS, G, T}, i) where {TS, G, T}
        -     if !isforced(m)
        -         return -zero(T)
        -     elseif isunstable(m)
        -         return ùí≤_unstable_U(m, i)
        -     else
        -         return ùí≤_stable(m, i)
        -     end
        - end
        - 
        - "Return the turbulent velocity scale for tracers at face point i."
        - @inline function ùí≤_T(m::AbstractModel{TS, G, T}, i) where {TS, G, T}
        -     if !isforced(m)
        -         return -zero(T)
        -     elseif isunstable(m)
        -         return ùí≤_unstable_T(m, i)
        -     else
        -         return ùí≤_stable(m, i)
        -     end
        - end
        - 
        - const ùí≤_V = ùí≤_U
        - const ùí≤_S = ùí≤_T
        - 
        - #
        - # Non-local flux
        - #
        - 
        - """
        -     NL(CNL, flux, d, shape=default_shape)
        - 
        - Returns the nonlocal flux, N = CNL*flux*shape(d),
        - where `flux` is the flux of some quantity out of the surface,
        - `shape` is a shape function, and `d` is a non-dimensional depth coordinate
        - that increases from 0 at the surface to 1 at the bottom of the mixing layer.
        - 
        - Because flux is defined as pointing in the positive direction,
        - a positive surface flux implies negative surface flux divergence,
        - which implies a reduction to the quantity in question.
        - For example, positive heat flux out of the surface implies cooling.
        - """
        - NL(CNL, flux, d, shape=default_NL_shape) = CNL * flux * shape(d)
        - 
        - function ‚àÇNL‚àÇz(CNL::T, Fœï, d, Œîf, m) where T
        -     if isunstable(m)
        -         return (NL(CNL, Fœï, d) - NL(CNL, Fœï, d)) / Œîf
        -     else
        -         return -zero(T)
        -     end
        - end
        - 
        0 ‚àÇNLT‚àÇz(m, i) = @inbounds ‚àÇNL‚àÇz(m.parameters.CNL, m.state.FŒ∏, d(m, i), Œîf(m.grid, i), m)
        0 ‚àÇNLS‚àÇz(m, i) = @inbounds ‚àÇNL‚àÇz(m.parameters.CNL, m.state.Fs, d(m, i), Œîf(m.grid, i), m)
        - 
        - #
        - # Equation specification
        - #
        - 
        - # K_{U,V,T,S} is calculated at face points
        - @inline KU(m, i) = K_KPP(m.state.h, ùí≤_U(m, i), d(m, i)) + m.parameters.KU‚ÇÄ
        - @inline KT(m, i) = K_KPP(m.state.h, ùí≤_T(m, i), d(m, i)) + m.parameters.KT‚ÇÄ
        - @inline KS(m, i) = K_KPP(m.state.h, ùí≤_S(m, i), d(m, i)) + m.parameters.KS‚ÇÄ
        - const KV = KU
        - 
        - #@inline KU(m, i) = K_KPP(m.state.h, ùí≤_U(m, i), d(m, i)) + m.parameters.KU‚ÇÄ
        - #const KT = KS = KV = KU
        - 
        - 
        - @inline RU(f, V, i) = @inbounds  f*V[i]
118755888 @inline RV(f, U, i) = @inbounds -f*U[i]
        - 
        - @inline RU(m, i) = RU(m.constants.f, m.solution.V, i)
        - @inline RV(m, i) = RV(m.constants.f, m.solution.U, i)
        - @inline RT(m, i) = -‚àÇNLT‚àÇz(m, i)
        - @inline RS(m, i) = -‚àÇNLS‚àÇz(m, i)
        - 
        - end # module
        - 
